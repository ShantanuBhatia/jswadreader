/*
Before you start reading:
1. 	the Unofficial Doom Spec being referred to throughout this code
	can be found at http://www.gamers.org/dhs/helpdocs/dmsp1666.html
	It is an EXCELLENT document and I highly suggest reading it before reading this code
	I promise it'll help you understand it better

2. 	WAD files are LITTE-ENDIAN.

3. Wherever the specs refer to a " 'tag' or 'trigger' " I have stuck to the term tag.

3. 	This is a learning project, and I welcome constructive feedback. 
	I'm only here because I love Doom and I want to learn Javascript.
	And if there is something you can teach me, I'd love for you to share :)
*/

const fs = require('fs');
const express = require('express');
const { promisify } = require("util");

// TODO: eventually replace with command-line WAD loading
const wadPath = "./doom1.wad"; // Rip and tear! :D
const readMode = 'r'; // So we don't mess up and write over the WAD file. Easier to read than 'r'
const dirEntrySize = 16;
const headerSize = 12;


// So we can use promises and async/await on file operations instead of getting into callback hell
const read = promisify(fs.read);
const openFile = promisify(fs.open);


/*
Every great game should have an awful ASCII art title header
This ASCII art for the heading "ShantyDoom" comtains both backtick ` and backslash \ characters.
Both of these have been be escaped w/ backslashes to render correctly.
*/
titleText = `  _________.__                   __           ________                         
 /   _____/|  |__ _____    _____/  |_ ___.__. \\______ \\   ____   ____   _____  
 \\_____  \\ |  |  \\\\__  \\  /    \\   __<   |  |  |    |  \\ /  _ \\ /  _ \\ /     \\ 
 /        \\|   Y  \\/ __ \\|   |  \\  |  \\___  |  |    \`   (  <_> |  <_> )  Y Y  \\
/_______  /|___|  (____  /___|  /__|  / ____| /_______  /\\____/ \\____/|__|_|  /
        \\/      \\/     \\/     \\/      \\/              \\/                    \\/ `;


/*
Returns JSON of the WAD's header data
fd: file descriptor of wad file

The first twelve bytes of the WAD file contain:
four bytes of ASCII text saying if this is an IWAD or a PWAD
four bytes of a little-endian long int telling how many lumps there are
four bytes of a little-endian long int telling the offset from 
	the start of the file to the beginning of the directory
*/
const getWadHeader = async (fd) => {
	let buf = Buffer.alloc(headerSize);
	let headerInfo = await read(fd, buf, 0, headerSize, 0);
	//TODO: error if the file doesn't start with IWAD or PWAD
	return ({
		"wadType": headerInfo.buffer.toString('utf8', 0, 4),
		"noOfLumps": headerInfo.buffer.readUInt32LE(4),
		"dirOffset": headerInfo.buffer.readUInt32LE(8)
	});
}


/*
Returns JSON of a single lump's entry in the WAD directory. 
fd: file descriptor of wad file
offset: offset from start of file at which this directory entry starts

From the unofficial Doom Specs:
The directory has one 16-byte entry for every lump. Each entry consists
of three parts:
    (a) a long integer, the file offset to the start of the lump
    (b) a long integer, the size of the lump in bytes
    (c) an 8-byte ASCII string, the name of the lump, padded with zeros.
	  	For example, the "DEMO1" entry in hexadecimal would be
	  	(44 45 4D 4F 31 00 00 00)
*/
const readDirEntry = async (fd, entryOffset) => {
	let buf = Buffer.alloc(dirEntrySize);
	let dirEntryObj = await read(fd, buf, 0, dirEntrySize, entryOffset);
	let dirEntry = {
		"lumpStartOffset": dirEntryObj.buffer.readUInt32LE(0),
		"lumpSize": dirEntryObj.buffer.readUInt32LE(4),
		// the name string is zero-padded as demo'd above, and JS wants to show these zeroes as the \u0000 character
		// but we don't want that, and trim() doesn't get rid of them, so we regex them away
		"lumpName": dirEntryObj.buffer.toString('utf8', 8, 16).replace(/\0/g, '')
	}
	return dirEntry;
}


/*
Returns a array of JSON objects for all entries in the WAD directory. 
fd: file descriptor of wad file
wadHeader: JSON object created by getWadHeader() describing wad type, lump count, and directory offset.

Starting at the directory starting offset, create entries for each 16-byte directory item. 
List them and return the list.
*/
const readWadDirectory = async (fd, wadHeader) =>  {
	let indices = [...Array(wadHeader.noOfLumps).keys()];
	return Promise.all(
		indices.map( async (x) => { 
			const entry = await readDirEntry(fd, wadHeader.dirOffset+(x*dirEntrySize));
			return entry;
		})
	);
}


/*
Returns an array of JSON objects containing all the directory entries for a given level
wadDirectory: the ordered array of JSON of the WAD's directory entries. Generated by readWadDirectory().

From the Unofficial Doom Spec Each level has eleven directory entries and ten lumps: 
	E[x]M[y] (orMAPxy in a DOOM 2 wad), THINGS, LINEDEFS, SIDEDEFS, VERTEXES, SEGS,
	SSECTORS, NODES, SECTORS, REJECT, and BLOCKMAP.
*/
 const getAllMaps =  (wadDirectory) => {
 	let levelData = [];
 	for (const [index, lump] of wadDirectory.entries()){
 		if(lump.lumpName.match(/^E[0-9]M[0-9]$/g)){
 			console.log(`loaded in level ${lump.lumpName}`);
 			levelData.push({
 				"LEVEL_entry": lump.lumpName,
 				"THINGS_entry": wadDirectory[index+1],
 				"LINEDEFS_entry": wadDirectory[index+2],
				"SIDEDEFS_entry": wadDirectory[index+3],
				"VERTEXES_entry": wadDirectory[index+4],
				"SEGS_entry": wadDirectory[index+5],
				"SSECTORS_entry": wadDirectory[index+6],
				"NODES_entry": wadDirectory[index+7],
				"SECTORS_entry": wadDirectory[index+8],
				"REJECT_entry": wadDirectory[index+9],
				"BLOCKMAP_entry": wadDirectory[index+10]
 			});
 		}
 	}

 	return levelData;
 }


const readTHINGS = async (fd, THINGS_entry) => {
	let buf = Buffer.alloc(THINGS_entry.lumpSize);
	let thingCount = THINGS_entry.lumpSize / 10;

	console.log(`SIZE: ${THINGS_entry.lumpSize}. No of sectors: ${thingCount}`);
	return 5;
	// // read into the buffer the entire lump
	let thingLump = await read(fd, buf, 0, THINGS_entry.lumpSize, THINGS_entry.lumpStartOffset);

	let THINGS = [];
	for(let i = 0; i < thingCount; i++){
		THINGS.push({
			"x_pos": thingLump.buffer.readInt16LE((i*7)),
			"y_pos": thingLump.buffer.readInt16LE((i*7)+2),
			"angle": thingLump.buffer.readInt16LE((i*7)+4),
			"type": thingLump.buffer.readInt16LE((i*7)+6),
			"options": thingLump.buffer.readInt16LE((i*7)+8)
		});
	}
	return THINGS;
}


/*
Returns an array of JSON objects representing the LINEDEFS in the lump whose directory entry we pass in

fd: WAD's file descriptor
LINEDEFS_entry: JSON object of LINEDEFS lump directory entry
From the Unofficial Doom Specs:

Each linedef represents a line from one of the VERTEXES to another,
and each linedef's record is 14 bytes, containing 7 <short> fields:

	(1) from the VERTEX with this number (the first vertex is 0).
	(2) to the VERTEX with this number (31 is the 32nd vertex).
	(3) flags, see [4-3-1] below.
	(4) types, see [4-3-2] below.
	(5) is a "tag" or "trigger" number which ties this line's effect type
	      to all SECTORS that have the same tag number (in their last
	      field).
	(6) number of the "right" SIDEDEF for this linedef.
	(7) "left" SIDEDEF, if this line adjoins 2 SECTORS. Otherwise, it is
	      equal to -1 (FFFF hex).

*/
const readLINEDEFS = async (fd, LINEDEFS_entry) => {
	let buf = Buffer.alloc(LINEDEFS_entry.lumpSize);
	let linedefCount = LINEDEFS_entry.lumpSize / 14;

	console.log(`SIZE: ${LINEDEFS_entry.lumpSize}. No of sectors: ${linedefCount}`);
	
	// read into the buffer the entire lump
	let linedefLump = await read(fd, buf, 0, LINEDEFS_entry.lumpSize, LINEDEFS_entry.lumpStartOffset);

	let LINEDEFS = [];
	for(let i = 0; i < linedefCount; i++){
		LINEDEFS.push({
			"FROM_vertex": linedefLump.buffer.readInt16LE((i*7)),
			"TO_vertex": linedefLump.buffer.readInt16LE((i*7)+2),
			"flags1": linedefLump.buffer.readInt16LE((i*7)+4),
			"flags2": linedefLump.buffer.readInt16LE((i*7)+6),
			"tag": linedefLump.buffer.readInt16LE((i*7)+8),
			"rightSideNo": linedefLump.buffer.readInt16LE((i*7)+10),
			"leftSideNo": linedefLump.buffer.readInt16LE((i*7)+12)

		});
	}
	return LINEDEFS;
}




const constructLevel = async (fd, levelJSON) => {
	let tmp = await readLINEDEFS(fd, levelJSON.LINEDEFS_entry);
	console.log(JSON.stringify(tmp[0]));
	let tmp2 = await readTHINGS(fd, levelJSON.THINGS_entry);
	console.log(JSON.stringify(tmp2[0u]));

}





// TODO: reject running if the file provided is not a WAD
const main = async () => {
	console.log(titleText);
	console.log("Doom! In Javascript! By Shanty!");
	let fd = await openFile(wadPath, readMode);
	console.log(`WAD file has been opened at fd ${fd}`);
	let doomWadHeader = await getWadHeader(fd);
	console.log(JSON.stringify(doomWadHeader));
	let x = await readWadDirectory(fd, doomWadHeader);
	console.log(JSON.stringify(x[0]));
	let y = getAllMaps(x);
	constructLevel(fd, y[0]);

}


main();